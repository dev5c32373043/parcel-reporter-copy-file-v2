{"mappings":"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","sources":["src/index.js","src/utils.js","src/parseSettings.js","src/copyFiles.js","src/opsLimiter.js"],"sourcesContent":["const { Reporter } = require('@parcel/plugin');\n\nconst utils = require('./utils');\nconst parseSettings = require('./parseSettings');\nconst copyFiles = require('./copyFiles');\nconst opsLimiter = require('./opsLimiter')();\n\nconst copyFileReporter = new Reporter({\n  async report({ event, options }) {\n    if (event.type === 'buildSuccess') {\n      // Get all dist dir from targets, we'll copy static files into them\n      const bundles = event.bundleGraph.getBundles();\n\n      const bundleTargets = Array.from(new Set(\n        bundles.filter(b => b.target && b.target.distDir).map(b => b.target.distDir),\n      ));\n\n      const filesToCopy = await parseSettings(options.projectRoot, bundleTargets);\n\n      if (!utils.isArray(filesToCopy)) return; // if no files to copy, there is nothing to do for us\n\n      for (const fileToCopy of filesToCopy) { // dividing copy files operations by groups\n        const copyDistFn = () => Promise.all(\n          fileToCopy.distPaths.map(distPath => (\n            Promise.all(\n              fileToCopy.staticPaths.map(staticPath => (\n                copyFiles(staticPath.path, distPath, utils.omit(staticPath, 'path'))\n              )),\n            )\n          )),\n        );\n\n        opsLimiter.queue.push(copyDistFn);\n      }\n\n      await opsLimiter.exec(); // executing operations by chunks\n    }\n  },\n});\n\nmodule.exports = copyFileReporter;\n","const utils = {};\n\nutils.await = promise => promise.then(data => [null, data]).catch(err => [err]);\n\nutils.isArray = Array.isArray;\nutils.isNumber = obj => typeof obj === 'number' && Number.isFinite(obj);\nutils.isString = str => typeof str === 'string';\nutils.isPlainObject = obj => typeof obj === 'object' && obj !== null && obj.toString() === '[object Object]';\n\nutils.isEmpty = obj => {\n  if (utils.isNumber(obj)) return false;\n  if (utils.isArray(obj)) return !obj.length;\n  if (utils.isPlainObject(obj)) return !Object.keys(obj).length;\n  if (utils.isString(obj)) return !obj.length;\n  return true;\n};\n\nutils.omit = (obj, _keys) => {\n  const newObj = {};\n  const keys = utils.isString(_keys) ? [_keys] : _keys;\n\n  if (!utils.isPlainObject(obj) || !utils.isArray(keys)) return newObj;\n\n  Object.keys(obj).forEach(key => {\n    if (keys.includes(key)) return;\n    newObj[key] = obj[key];\n  });\n\n  return newObj;\n};\n\nmodule.exports = utils;\n","const fs = require('fs/promises');\nconst path = require('path');\n\nconst { promisify } = require('util');\n\nconst glob = require('glob');\n\nconst utils = require('./utils');\n\n/**\n * Parses required instructions for files copy.\n * @param {String} projectPath root directory of the project\n * @param {String[]} bundleTargets dist folders destination for bundle\n */\n\nconst parseSettings = async (projectPath, bundleTargets) => {\n  const packageJson = JSON.parse(await fs.readFile(path.join(projectPath, 'package.json')));\n  const { copyStaticFiles } = packageJson;\n\n  const filesToCopy = [];\n\n  if (!utils.isArray(copyStaticFiles)) return filesToCopy;\n\n  for (const itemToCopy of copyStaticFiles) {\n    let staticPaths; let distPaths;\n\n    if (utils.isString(itemToCopy)) {\n      staticPaths = path.join(projectPath, itemToCopy);\n      distPaths = bundleTargets;\n    } else if (utils.isPlainObject(itemToCopy)) {\n      staticPaths = path.join(projectPath, itemToCopy.from);\n      distPaths = utils.isString(itemToCopy.to) ? [path.join(projectPath, itemToCopy.to)] : bundleTargets;\n    }\n\n    if (glob.hasMagic(staticPaths)) {\n      const globResults = await promisify(glob)(staticPaths); // eslint-disable-line no-await-in-loop\n      staticPaths = globResults.reduce((res, _path, aIdx, arr) => { // excluding files when whole dir matched to prevent dups\n        if (!arr.some(p => (p !== _path && _path.includes(p)))) {\n          res.push({ path: _path, keepDir: true });\n        }\n\n        return res;\n      }, []);\n    } else if (utils.isString(staticPaths)) {\n      staticPaths = [{ path: staticPaths, keepDir: false }];\n    }\n\n    if (!utils.isEmpty(staticPaths) && !utils.isEmpty(distPaths)) {\n      filesToCopy.push({ staticPaths, distPaths });\n    }\n  }\n\n  return filesToCopy;\n};\n\nmodule.exports = parseSettings;\n","const fs = require('fs/promises');\nconst path = require('path');\nconst { pathToFileURL } = require('url');\n\nconst utils = require('./utils');\n\n/**\n * Copy of target directory/file into the specified directory.\n * @param {String} filePath directory of file path\n * @param {String} fromPath path where directory/file placed\n * @param {String} toPath destination path where to copy the directory/file\n * @param {String} fileName file basename\n */\n\nconst syncFn = async (filePath, fromPath, toPath, fileName) => {\n  let destPath = filePath.replace(fromPath, toPath);\n\n  if (!fileName) {\n    const [accessDestErr] = await utils.await(fs.access(destPath));\n\n    if (accessDestErr) {\n      await fs.mkdir(destPath, { recursive: true });\n    }\n\n    return;\n  }\n\n  if (fileName && path.posix.basename(destPath) !== fileName) { // adding filename into path when only dir provided\n    destPath = path.posix.join(destPath, fileName);\n  }\n\n  await fs.copyFile(pathToFileURL(filePath), destPath);\n};\n\n/**\n * Recursively copies all folders & files into the specified directory.\n * @param {String} targetPath root directory to start from\n * @param {Object} options config that contain basic info to sync folders/files\n * @param {String} options.fromPath path where directory/file placed\n * @param {String} options.toPath destination path where to copy the directory/file\n * @param {Boolean} options.keepDir flag that helps determine when we should keep target folder\n * @param {Boolean} initCall flag that helps determine first call of the recursive function\n\n */\n\nconst recursiveSync = async (targetPath, options, initCall = true) => {\n  const mainStats = await fs.stat(targetPath);\n\n  if (mainStats.isFile()) { // if a single file provided\n    await syncFn(targetPath, options.fromPath, options.toPath, path.posix.basename(targetPath));\n    return;\n  }\n\n  if (initCall && options.keepDir) { // we should keep dir in this case\n    const parentDir = path.posix.dirname(options.fromPath);\n    await syncFn(targetPath, parentDir, options.toPath);\n    const newOptions = { ...options, fromPath: parentDir };\n    await recursiveSync(targetPath, newOptions, false);\n    return;\n  }\n\n  const fileNames = await fs.readdir(targetPath);\n\n  await Promise.all(fileNames.map(async fileName => { // syncing all files/directories inside target dir\n    const filePath = path.posix.join(targetPath, fileName);\n    const stats = await fs.stat(filePath);\n\n    if (stats.isDirectory()) {\n      await syncFn(filePath, options.fromPath, options.toPath);\n      await recursiveSync(filePath, options, false);\n      return;\n    }\n\n    await syncFn(filePath, options.fromPath, options.toPath, fileName);\n  }));\n};\n\nconst copyFiles = async (_fromPath, _toPath, _options = {}) => {\n  const fromPath = path.posix.resolve(_fromPath);\n  const toPath = path.posix.resolve(_toPath);\n  const options = { ..._options, fromPath, toPath };\n\n  const [accessErr] = await utils.await(fs.access(toPath));\n  if (accessErr) { // creating destination folder\n    await fs.mkdir(toPath, { recursive: true });\n  }\n\n  return recursiveSync(fromPath, options);\n};\n\nmodule.exports = copyFiles;\n","module.exports = () => ({\n  queue: [],\n  async exec(limit = 5) {\n    const currentOps = this.queue.splice(0, limit);\n\n    await Promise.all(currentOps.map(op => op()));\n\n    if (this.queue.length <= 0) return;\n\n    await this.exec(limit);\n  },\n});\n"],"names":[],"version":3,"file":"main.js.map","sourceRoot":"../"}